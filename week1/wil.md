## 웹이란?
웹이란 여러 컴퓨터가 서로 연결되어 정보를 공유하는 공간을 말한다.   

웹이라는 가상의 공간에서, 둘 이상의 컴퓨터끼리 모여 필요한 데이터를 주고 받기도 하고, 데이터를 원하는 방식으로 조작하기도 한다. 가장 대표적으로 웹에서 사용하는 방식인 **클라이언트 서버 패러다임**을 통해 더 자세히 설명하겠다.   

---
### 클라이언트 서버 패러다임
클라이언트 서버 패러다임은 웹 내에서 **클라이언트 컴퓨터와 서버 컴퓨터** 간에 이루어지는 데이터 요청 및 전달 방식을 일컫는다.
 
여기서 클라이언트 컴퓨터는 서버에게(서버 컴퓨터에게) 자신이 얻고 싶은 데이터를 요청하는 컴퓨터를 말한다. 쉽게 말해서 우리가 쓰고 있는 컴퓨터가 클라이언트 컴퓨터다.   
(물론 엄밀히 말하자면 모든 클라이언트 컴퓨터가 우리가 쓰는 컴퓨터인 것은 아니다. 이는 차후에 설명하겠다.)    

서버 컴퓨터란, 특정 서버를 관리하고, 클라이언트 컴퓨터의 요청에 따라 데이터를 제공하는 컴퓨터를 말한다. 클라이언트 서버 패러다임은 웹에서 작동하는 방식이기 때문에, 서버도 사실상 **컴퓨터로 운영**된다. 그래서 서버 **컴퓨터**라고 부르는 것이다.    

(글 초반에는 서버와 클라이언트 뒤에 컴퓨터를 붙여서 내용을 전개하고, 후반부에서는 그냥 서버와 클라이언트라고 부르겠다.)

---
![](https://velog.velcdn.com/images/tss9752/post/68de15ec-452b-411e-99e2-7791ae2f2b7d/image.png)
위 사진을 통해 클라이언트 서버 패러다임을 다시 설명해보겠다. 클라이언트 컴퓨터가 서버 컴퓨터에게 특정 데이터 A를 요구하면, 서버 컴퓨터는 해당 요청에 따라 데이터를 찾아서 클라이언트 서버에게 제공한다.   

가령 우리가 네이버 웹페이지를 컴퓨터 화면에 띄우고 싶다고 하자. 그러면 클라이언트 컴퓨터는 웹페이지에 대한 정보를 요구하는 우리 컴퓨터가 되고, 서버 컴퓨터는 네이버 웹페이지를 관리하는 컴퓨터가 되겠다. 우리가 서버 컴퓨터(네이버 웹페이지를 관리하는 컴퓨터)에게 데이터를 요청하면, 서버 컴퓨터는 웹페이지 데이터를 가져와 우리에게 제공한다. 우리 클라이언트 컴퓨터는 그 데이터를 받아 화면에 웹페이지를 띄워준다. 이 방식으로 데이터를 요청하고 반환받는 것이다.   

하지만 특정 컴퓨터가 항상 서버 컴퓨터이기만 하거나 항상 클라이언트 컴퓨터인 것은 아니다. 다시 말해서 어떤 상황에서는 클라이언트였다가 다른 상황에서는 서버 컴퓨터가 될 수도 있다.   
![](https://velog.velcdn.com/images/tss9752/post/5bcc8db6-eecc-425e-8312-72dd0c545281/image.png) 
아까 사진에서 수정한 버전이다. 만약 클라이언트가 서버 컴퓨터에게 A 데이터를 요청하고, 그 요청을 받은 서버 컴퓨터가 다시 서버* 컴퓨터에게 A 데이터를 요청하는 상황을 생각해보자. 가운데에 낀 서버 컴퓨터는 클라이언트에게 받은 데이터 요청을 처리한다는 점에서 서버 컴퓨터이기도 하지만, 서버* 컴퓨터에게 A 데이터를 달라고 요청하는 것을 보면 클라이언트 컴퓨터이기도 하다.   

즉, **클라이언트 - 서버** 관계에서 서버 컴퓨터는 **서버 컴퓨터**이지만,   
**서버 - 서버\*** 관계에서는 서버 컴퓨터가 **클라이언트 컴퓨터**이다.   

이렇듯, 특정 컴퓨터가 역할이 고정되어 있는 것이 아니다. 서버였다가, 클라이언트였다가 하는 식으로, 유동적으로 바뀔 수 있다.

#### + 추가 : 프론트엔드와 백엔드로 나눠서 작업하는 이유
웹 페이지를 자세히 보면, 고정되어 바뀌지 않는 화면 UI가 있는 반면 계속해서 내용이 바뀌는 컨텐츠도 있다.
![](https://velog.velcdn.com/images/tss9752/post/0c562a45-f938-4658-8875-6addf28d400b/image.png)
네이버 웹페이지를 보자. 네이버 로그인 구역, 뉴스스탠드를 보여주는 구역, 날씨를 보여주는 구역 등 특정 컨텐츠를 제공하는 틀(UI)은 고정되어 변하지 않지만, 날씨의 내용은 날마다, 시간마다 변한다. 쇼핑 구역에서는 광고할 제품이 계속 바뀐다. 그렇다면 이 끊임없이 변하는 컨텐츠에 발맞춰 수많은 웹페이지를 만들어야 할까? 당연히 아닐 것이다.   

그래서 우리는 자주 변하지 않는 화면 UI는 프론트엔드로, 자주 변하는 컨텐츠는 백엔드로 구현한다. 이것이 개발자 사이에서 자명한 프-백 구조의 탄생이다. (요즘은 ai를 활용하는 기술도 합쳐져서 프-백-ai 구조로서 존재하기도 한다.)

흐름을 표현하면 다음과 같다.
|클라이언트||프론트엔드 서버/클라이언트||백엔드 서버|
|:--:|:--:|:--:|:--:|:--:|
|1. 컨텐츠 데이터 요청| → |2. 컨텐츠 데이터 요청| → |3. 데이터 찾기|
|||||↓|
|6. 데이터가 화면에 띄워짐| ← |5. 데이터 화면에 띄움 | ← |4. 컨텐츠 데이터 전달|

---
## 프로토콜이란?, HTTP 프로토콜
프로토콜이란 네트워크 안에서 컴퓨터 간에 요청과 응답을 주고 받는 **규칙**을 말한다.   
![](https://velog.velcdn.com/images/tss9752/post/68de15ec-452b-411e-99e2-7791ae2f2b7d/image.png)
다시 이 상황을 보자. 클라이언트 컴퓨터와 서버 컴퓨터가 정보를 주고 받기는 하는데, 일정한 규칙을 통해 정보 전달이 되어야 할 것이다. 누구는 방식 1번으로 정보를 요구하고, 또 누구는 4번 방식으로 요구하면 데이터 처리 간에 혼란이 발생한다. 이를 막고자 규격화된 데이터 요청-처리 규칙인 프로토콜이 등장했다.   

그리고 웹에서는 HTTP 프로토콜이 사용된다. HTTP 프로토콜에서는 클라이언트가 정보를 요청하는 방식에 대한 규칙, 서버가 정보를 제공하고 그 응답을 제공하는 방식이 규정되어 있는데, 이를 알아보도록 하자.

### HTTP - 데이터 요청
클라이언트 컴퓨터가 데이터 요청을 하기 위해서는 HTTP Method, URL을 통해 데이터를 요청한다.
1. HTTP Method : 데이터를 다루는 방법에 대한 내용을 담는다. 일종의 동사라고 생각할 수 있다. HTTP Method의 대표적인 종류는 다음과 같다.
     * **GET** : 데이터를 가져와달라고 요청한다.
     * **POST** : 데이터를 생성해달라고 요청한다. 중복 생성을 허용한다.
     * **PUT** : 데이터를 생성해달라고 요청한다. 단, 중복 생성을 허용하지 않는다. 만약 중복된 데이터가 존재하면 그 데이터는 지우고 새롭게 PUT으로 요규한 데이터로 교체한다.
     * **PATCH** : 데이터의 일부분만 수정해달라고 요청한다. 만약 데이터 A가 존재하는데, A의 수정본 데이터인 A'을 요청한다면, A에 수정을 가하여 A'으로 만든다.
     * **DELETE** : 데이터를 삭제해달라고 요청한다.   


2. URL : 다룰 데이터의 위치를 의미한다. 일종의 명사다. 그래서 HTTP Method에 대한 대상을 URL에서 다룬다. URL은 다음과 같이 구성된다.
     > URL = 프로토콜 + 서버주소 + 서버 내 데이터 위치

     예를 들면, ```http://www.example.com/user/1/nickname``` 에서,
     * ```http``` : 프로토콜
     * ```www.example.com``` : 서버 주소. ~~~.com 같은 도메인 네임으로 표현하기도 한다.
     * ```user/1/nickname``` : 서버 내 데이터 위치. user 안에 있는 1 디렉토리 내의 nickname에 있는 정보다.
     
     위에서 봤던 ```http://www.example.com/user/1/nickname``` 에서, ```user/1/nickname```이 1번 user의 nickname을 가져오는 정보 경로라고 하자. 그러면 user가 한 명만 있는 것이 아니니 ```user/2/nickname```도 있고, ```user/3/nickname```도 있고, ```user/10000/nickname```도 있고... 여러 user가 있을 것이다. 이에 대한 모든 파일 경로를 설정하는 것은 바람직하지 않을 것이다. 가변적인 user 서수를 설정할 수 있는 **Path Parameter**를 이떄 사용할 수 있다.   

     * Path Paremeter : URL의 일반화된 표현방법.   

        가령, 수도 없이 많은 ```user/(n)/nickname``` 부분을
      ```http://www.example.com/user/{uesr_id}/nickname```   
      처럼 설정할 수 있다. 이러면 숫자 부분을 user_id로 설정하여 일반화시킨 것인데, 나중에 아무리 많은 숫자가 들어와도 user_id라는 Path Parameter를 통해 처리할 수 있다.

     한편, 특정 경로를 통해서 데이터를 처리할 수도 있지만 구체적인 값을 처리해야 하는 상황도 발생할 것이다.   
     가령 네이버에서 "ez1hub"를 검색한다고 하자. 그러면 ex1hub라는 매개값을 어떻게 서버 컴퓨터에서 처리할 것인가? 이는 서버 컴퓨터에서 임의로 경로를 설정해 모든 데이터를 처리하기는 곤란하다. 이 경우에서는 **Query String**이라는 것을 통해 처리할 수 있다.

     * Query String (= Request Paremeter) : 데이터 위치 뒤에 구체적인 데이터 내용을 작성하는 영역.   

        가령, ```~~~com/post/search?page=1&keyword=hello```을 보면,   
        **?** 뒤에 내용이 Query String이다. 마치 파이썬 딕셔너리처럼 ```key = value``` 형식으로 작성하고 각 묶음은 &로 구분한다.    

        그래서 해당 Query String은
        + ```page=1``` : 1번 page에서
        + ```keyword=hello``` : hello라는 단어를 검색한다.   

        로 파악할 수 있다.
  
---
### HTTP - 데이터 전송 응답 메세지
서버 컴퓨터가 데이터를 클라이언트에게 제공할 때, 데이터가 제대로 처리되었는가 아닌가에 대한 결과 메세지도 같이 제공한다. 그 결과 메세지를 **상태 코드**라고 한다.    
다음은 대표적인 상태 코드들이다.
+ 200 : 처리 성공 (OK)
+ 201 : 데이터 생성 성공 (Created)
+ 400 : 클라이언트 요청 오류 (Bad request) : 클라이언트 쪽에서 문제가 있다는 뜻이다.
+ 404 : 요청 데이터 없음 (not found) : 클라이언트가 요청한 데이터가 서버에 존재하지 않는다는 뜻이다.
+ 500 : 서버 에러 (internal server error) : 서버에 문제가 있다는 뜻이다.
    
---
### 주고 받는 데이터의 공통적인 규칙 : HTTP 헤더, 바디
클라이언트와 서버가 각각 데이터를 요청하고 제공할 때 공통적으로 어떤 틀을 지킨다. HTTP 데이터를 구성하는 HTTP 헤더, 바디가 그것이다. 이를 구체적으로 알아보자.

* 헤더 : 통신에 대한 정보. 언제 보냈는지, 누가 보내는지, Method 종류, 요청 경로 등을 포함한다. 서버 컴퓨터가 보내는 상태 코드가 HTTP 헤더에서 제공된다.
* 바디 : 주고 받는 데이터 실제 내용. json 형식으로 작성하고, 원한다면 생략할 수 있다.
![](https://velog.velcdn.com/images/tss9752/post/ee15dc0b-247e-42fe-bd45-d7ac6cfeeb4d/image.png)

아래 사진 예시를 통해 자세히 알아보자.
![](https://velog.velcdn.com/images/tss9752/post/0777f805-3465-45ad-9b00-9810068ae885/image.png)
이 상황에서 클라이언트가 HTTP 바디에 있는 유저의 정보를 생성해달라고 서버 컴퓨터에게 요청한다. 그리고 이것을 규격화된 틀인 HTTP 헤더와 HTTP 바디를 통해서 전달한다.   
![](https://velog.velcdn.com/images/tss9752/post/15f5b692-8af1-4062-a825-7bbc45a77b58/image.png)
이번엔 클라이언트가 서버에게 유저1 정보를 조회해달라고 요청한다. 단순 요청만 하는 것이고 서버에게 전달할 데이터 내용은 없으니 HTTP 바디가 생략된 모습이다.   
이 상황에서 서버는 클라이언트의 요청에 따라 유저1의 정보를 HTTP 바디에 담고 이에 해당하는 HTTP 헤더도 같이 클라이언트에게 전달한다.

---
## API란?
HTTP는 데이터를 주고받는 **규칙**이었다. API가 탄생하기 전, HTTP라는 규칙 내에서 컴퓨터 프로그램(어플리케이션)은 서로 어떻게 데이터를 주고 받을지에 대한 **통신 방법**을 따로 정의하지 않았다.    

가령, 철수가 영희가 사는 A나라에서는 편지를 작성할 때 지켜야 하는 규칙을 나라에서 규정해놨다고 하자. 맨 처음에 받는이를 쓰고, 그 다음에 편지 내용, 마지막으로 작성이를 쓴 다음, 맨 아래에 국명을 작성하는 규칙을 규정해놨다고 하자.    
철수는 영희한테 편지를 보내려고 한다. 정해진 규칙을 통해 편지를 작성하고, 이제 영희에게 전달하면 된다. 근데 편지를 쓰는 규칙만 정해졌지, 편지를 어떻게 전달하는지에 대한 규칙이 규정되지 않았다. 누구는 걸어서, 누구는 말을 타고, 누구는 우주선을 타고 편지를 전달할 것이다. A나라는   편지를 전달하는 방식을 하나로 통일하고 싶다.   

여기서, 편지를 작성하는 규칙을 HTTP로 다시 읽어보자. 그러면 API, HTTP 간의 차이점과 API의 중요성이 눈에 들어올 것이다.   
HTTP를 통해 데이터를 요청하고 전송하는 규칙은 정해졌지만 그 규칙 내에서 구체적으로 어떻게 데이터를 다룰지에 대한 **방법**은 정해지지 않았다. 그래서 웹 HTTP에서는 이를 **API**를 통해 정해놓는다.  

API(Application Programming Interface)란, 어플리케이션에서 원하는 기능을 수행하기 위해 통신 방법을 추상적으로 정의한 것이다.   

여기서 **추상적**으로 정의했다고 하는 이유는, 프론트엔드 - 백엔드 사이에서, 각 어플리케이션은 서로의 동작 과정을 알 필요가 없다. 그냥 정상적으로 통신만 하면 만사형통이기 때문이다.   
가령 우리가 우편을 보낼 때, 구체적으로 내가 보낸 우편이 어느 우체국으로 가서 어느 교류국을 어떤 방식으로 거치는지 알 필요가 없다. 보내는 방법만 알면 되기 때문이다.   
이처럼 API에서는 상대 어플리케이션의 동작 과정을 모두 명시하는 방식으로 통신 방법을 정의하지 않고, 필요한 부분만 서로에게 명시해줌으로써 통신이 가능하게끔 한다.

---
### REST API의 등장

시간이 지나면서 API 방식들이 너무 중구난방하다는 문제점이 제기되기 시작한다. API 사이에서도 통일되지 않는 상황이 발생한 것이다.   

이를 이해하기 위해서 다시 철수의 예시로 돌아가도록 하겠다.   
A나라에서는 편지를 모두 우편으로 보내도록 규정(API)했다. 그래서 철수가 영희에게 우편으로 편지를 보낸다고 하자. 편지를 작성해서 편지봉투에 넣고, 그 다음에 보내는 이의 이름과 주소, 받는 이의 이름과 주소 등을 명시할 것이다. 하지만 A나라에서는 우편으로 편지를 보내는 것 자체는 규칙으로서 자리 잡았지만 구체적으로 어떻게 우편을 보내는지에 대한 방식 자체가 규정되지 않았다. 누구는 보내는 이의 주소를 적지 않기도 하고, 누구는 우편 스티커를 붙이지 않는 등, 모두 다른 방식으로 우편을 보낸다. 이대로라면 우편 체계가 혼란스러워질 것이다.   

그래서 이를 방지하고자 획일화된 우편 발신 방법을 정한다. 이것이  웹 HTTP 상에서는 대표적으로, REST 아키텍쳐를 따르도록 설계한 **REST API**로 표현된다. REST API는 HTTP 요청 메세지와 마찬가지로 URL, HTTP Method로 구성되어 있다.

REST API를 잘 작성하기 위해서 규정해놓은 가이드라인이 있다. 한번 살펴보자.
1. 슬래시 구분자 (**/**)를 이용하여 경로의 계층을 구분한다.   
예를 들어,   
```http://www.example.com/user/1/nickname```
에서, /를 통해 user, 1, nickname 계층을 구분했다.  

2. URL 마지막에는 슬래시를 넣지 않는다.
```http://www.example.com/user/1/nickname/```   
이런 식으로 nickname 뒤에 /를 넣지 않는다.   

3. URL이 길어질 경우 언더바 기호(**_**)를 사용하지 말고 하이픈(**-**)을 사용한다.
```http://www.example.com/user/1/cafe_nickname``` (X)
```http://www.example.com/user/1/cafe-nickname``` (O)   

4. URL에는 소문자를 쓴다.   
```http://www.example.com/USER/1/NICKNAME``` (X)   
```http://www.example.com/user/1/nickname``` (O)   

5. 파일 확장자는 쓰지 않는다.   
```http://www.example.com/user/1/profile.jpg``` (X)   
```http://www.example.com/user/1/profile``` (O)   

이 규칙을 따라 작성한 훌륭한 API를 **RESTful API**라고 한다.

---
- GDGoC Weekly I Learned 검사용
![](https://velog.velcdn.com/images/tss9752/post/5f1d4d25-29ad-44e6-bc08-1daf7ca19fbd/image.png)

1. 유저 회원가입 / 로그인
+ 회원가입 : POST /register
+ 로그인 : POST /login
2. 나의 할 일 생성 / 조회 / 수정 / 삭제
+ 생성 : POST /todo
+ 조회 : GET /todo/list
+ 수정 : PATCH /todo/{todo_id}
+ 삭제 : DELETE /todo/{todo_id}
3. 나의 할 일 체크 / 체크 해제
+ 체크 : POST /todo/{todo_id}/check
+ 체크 해제 : POST /todo/{todo_id}/uncheck
4. 친구 찾기 / 팔로우 / 언팔로우 / 나의 친구 리스트 조회
+ 친구 찾기 : GET /friend
+ 친구 팔로우 : POST /friend/follow
+ 친구 언팔로우 : POST /friend/unfollow
+ 친구 리스트 조회 : GET /friend/list
5. 특정 친구의 할 일 조회
+ GET /friend/todo
