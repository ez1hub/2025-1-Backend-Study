## 스프링 프레임워크와 스프링부트 프레임워크 (Spring, SpringBoot)

### 0. 프레임워크(framework)
프레임워크란, 개발자가 개발할 때, 편리성을 제공하기 위해 제작된 도구 내지 틀이다.    

자동차를 만든다고 하자. 물론 처음부터 우리가 모든 부품을 다 재료를 찾아 제작한 다음에 조립해서 멋진 차를 만들 수도 있지만, 외부의 도움을 받아 공구도 사고, 완성된 부품을 받고, 정비소도 빌리면 매우 좋을 것이다.    
프레임워크를 사용해 개발을 한다는 것은 이렇게 외부의 도움을 간접적으로 받아 차를 제작(웹 개발)하는 것이다.   

가령 후술할 스프링부트 프레임워크는 웹 서버를 연동시켜주고, 데이터를 저장하는 데이터베이스와, 그 요소들 간의 소통 등등을 관리해주는 도구를 가지고 있다.    
프레임워크에는 여러가지가 있으며, 이 글에서는 스프링 프레임워크, 스프링부트 프레임워크에 대해 알아보겠다.   

---
### 1. 스프링 프레임워크 (Spring), 스프링부트 프레임워크 (SpringBoot)
스프링 프레임워크는 객체지향언어인 자바 진영의 대표적인 벡엔드 프레임워크다.    

클라이언트가 API를 이용하여 데이터베이스와 상호작용할 때, 둘 사이에 효율적인 데이터 전달이 이루어질 수 있도록 중간에서 관리해주는 프레임워크다. 스프링 프레임워크에는 스프링 빈이라고 하는 객체와 스프링 빈을 담아놓는 스프링 컨테이너가 존재한다.   

우리가 어떤 애플리케이션에서 로그인을 한다 하자. 프론트엔드 쪽에서 유저와 UI가 상호작용을 하고(로그인에 필요한 id나 비밀번호 입력 등), 로그인 정보를 입력하여 로그인을 시도하면, 서버 데이터베이스에 있는 유저 정보와 이러쿵저러쿵 해서 유저의 회원 정보가 데이터베이스에 있으니 로그인을 허락해줘야 한다.   

여기서 로그인 정보를 입력하여 로그인을 시도했을 때, 해당 내용의 API가 전달될 것이다.(가령 GET /user-id 처럼) 그러면 해당 API 작업이 데이터베이스와 프론트엔드 사이에서 잘 이루어질 수 있도록 도와주는 보조도구가 필요하다. 그것이 스프링 프레임워크가 하는 역할이다.

하지만 스프링의 단점이 드러나기 시작했다. 스프링에서 제공하는 도구, 기능이 번거롭고 복잡하다는 것이다.(왜 복잡하다고 하는지에 대한 일부 사례는 나중에 스프링 빈을 등록하는 절차를 설명할 때 이야기하겠다.)   
그래서 이를 보완해주기 위해 나타난 것이 바로 스프링부트 프레임워크다.    

---
스프링부트 프레임워크는 스프링을 사용할 때 편의를 더해주는 도구이자, 스프링 프레임워크의 확장판이다.     

스프링부트도 결국에 프레임워크의 일종이지만, 스프링부트는 확장판이기 때문에 스프링 없이 단독으로 사용이 불가하다. 따라서 스프링과 병용해야 한다.   
실제 현업 환경에서는 순수 스프링 프레임워크만 사용하기보다는, 스프링부트 프레임워크를 같이 사용하는 경우가 더 많다.   

다음 사진을 통해 유저, 스프링부트 프레임워크, 데이터베이스가 어떻게 상호작용하는지 알아보자.
![](https://velog.velcdn.com/images/tss9752/post/7668b3d8-2f2e-450c-bafb-b2c4ee7435c6/image.png)
외부 클라이언트에서 todolist 라는 어떤 리스트를 가져와달라고 요청한다. 클라이언트에서 나온 API가 스프링부트에 있는 내장 톰캣 서버에 전달하면, 내장 톰캣 서버는 스프링 컨테이너 안에서 만든 전용 컨트롤러에게 해당 데이터를 처리해달라고 하며 API 내용을 전달한다.(결국엔 전용 컨트롤러도 스프링 컨테이너 안에 있는 스프링 빈이다.) 그럼 컨트롤러는 데이터베이스(DB)와 상호작용하며 데이터를 요청하고, 받은 데이터를 JSON(프론트엔드와 백엔드가 소통하는 언어 형식이다.) 컨버터로 전달한다. JSON 형식으로 바뀐 데이터는 내장 톰캣 서버를 거친 뒤 클라이언트에게 전달된다.   
(내장 톰캣 서버에 대한 설명은 추후에 더 공부하고 작성하도록 하겠다.)   

이제 본격적으로 스프링 빈과 스프링 컨테이너에 대해 알아보겠다.

---
### 2. 스프링 빈(Spring Bean), 스프링 컨테이너(Spring Container)

스프링 빈이란, 애플리케이션 전역에서 사용할 공용 객체를 의미한다.    
스프링 프레임워크 내에 있는 스프링 빈은 애플리케이션에서 특정 기능의 구현을 실질적으로 담당하는 객체다. 웹 페이지에 있는 로그인 기능이라든가, 목록 삭제 기능 등은 모두 스프링 빈 객체와 이 안에 있는 메소드를 통해 이루어진다.   

그리고 스프링 컨테이너라고 하는 스프링 빈이 저장되는 공간에 빈을 저장해두고, 필요한 빈을 컨테이너에서 받아 사용한다. 만약 특정 빈을 제공해달라고 요청받으면, 컨테이너 안에 있는 스프링 빈을 반환해준다.   
![](https://velog.velcdn.com/images/tss9752/post/80e5f86b-f887-4a1d-8942-ebfa9fbe8adb/image.png)
![](https://velog.velcdn.com/images/tss9752/post/e8515fd4-c221-4b36-8af4-8248750a4fe6/image.png)
혹시 위 사진에서 이상한 점을 눈치챘는가? 바로 빈을 요구하는 객체도 스프링 빈이라는 것이다. 빈을 필요로 하는 객체도 빈이기 때문에, 결국 스프링 컨테이너 안에 있는 모든 빈끼리 서로를 필요로 하는 관계가 나타난다.
![](https://velog.velcdn.com/images/tss9752/post/c2c00415-b0af-4c29-bf1f-a90719bfdf2e/image.png)
필요한 빈은 스프링 프레임워크가 자동으로 가져다 준다.    
단, 빈이 아닌 객체가 빈을 요구하면 프레임워크가 자동으로 가져다주지 못한다. 무조건 빈인 객체가 요구해야 자동으로 빈을 받을 수 있다.

---
### 스프링 빈을 저장하는 방법
### 1. 설정 파일 작성 (수동등록) 
수동 등록 방법은 객체(빈)을 하나씩 다 설정한 다음에 스프링한테 전달하는 방식이다. 어떤 빈을 전달할지 설정 파일(설정 클래스) 한 개에 몽땅 몰아서 컨테이너에게 전달한다.   
 
![](https://velog.velcdn.com/images/tss9752/post/0c9666f2-61d7-4ec2-af3d-60699e89b342/image.png)
(본 실습은 Intellij, Java 17 버전으로 진행한다.)  
스프링 프레임워크 초기화면은 이렇게 뜰 것이다. 봐야 할 것은 src 패키지에 main과 test 패키지이다. 둘은 다음과 같은 용도로 사용한다.   
- main : 실제 사용될 코드를 작성하고 보관한다.
- test : 진짜 잘 작동하는지 검사하는 곳이다.

먼저, 수동 등록을 하는 과정을 쭉 적어보겠다.   
1. main 패키지에 빈의 타입이 되는 클래스를 생성한다.
2. test 패키지에 어떤 클래스 타입의 빈을 전달할지 규정하는 설정 클래스를 생성한다.
3. 그 설정 클래스 안에 빈을 생성하는 메소드를 생성한다.
4. test 패키지 내에 테스트 클래스 파일을 생성해, 컨테이너를 만든다.

---
- main 패키지에 빈의 타입이 되는 클래스를 생성한다.
![](https://velog.velcdn.com/images/tss9752/post/dec491e3-9a25-4668-a586-eadb296bf2e2/image.png)

 1. main 패키지 안에 있는 src 패키지에서, com.~~~패키지 밑에 새로운 패키지를 만든다.
 ![](https://velog.velcdn.com/images/tss9752/post/a1604730-1ea5-43ae-a62b-678e3e445b11/image.png)   

 2. 패키지 이름을 짓는다.
![](https://velog.velcdn.com/images/tss9752/post/68f032ae-0237-4d15-9aeb-dbaa7ad8fdb0/image.png)

 3. 그 패키지 안에 새로운 클래스를 만든다. 이 클래스가 빈의 타입이 된다.
![](https://velog.velcdn.com/images/tss9752/post/1116db95-633e-42ed-bfd9-1bdd94e10b57/image.png)

 4. 클래스 이름을 짓는다.
![](https://velog.velcdn.com/images/tss9752/post/08b6a134-1131-483b-a6c4-1137bef98745/image.png)
   
이러면 빈의 타입이 되는 클래스를 만든 것이다.   

---
- test 패키지에 어떤 클래스 타입의 빈을 전달할지 규정하는 설정 클래스를 생성한다.   
 1. test 패키지 밑에 설정 클래스를 담을 패키지를 생성한다.
![](https://velog.velcdn.com/images/tss9752/post/cc1bf932-ae39-4f44-8d02-72afdbebb94a/image.png)

 2. 이름을 정한다. (나는 이름을 Bean 클래스의 패키지와 같은 이름으로 설정했는데, 꼭 그럴 필요는 없다.)
 ![](https://velog.velcdn.com/images/tss9752/post/c6662b44-ca35-416e-971f-83b7f127e1d7/image.png)
 3. 패키지 안에 설정 클래스를 생성한다. 
  ![](https://velog.velcdn.com/images/tss9752/post/aae3144f-3533-4985-ab2b-82837155f635/image.png)

 4. 이름을 짓는다. ~~Config로 끝나는 이름으로 짓는 것이 관례다.
![](https://velog.velcdn.com/images/tss9752/post/02c8308c-d0fc-45f5-8a5c-47a2783b9ef7/image.png)

---
- 그 설정 클래스 안에 빈을 생성하는 메소드를 생성한다.
 1. 클래스명 위에 어노테이션 @Configuration 을 적는다. @Configuration 은 수동 방식으로 빈을 저장하는 클래스임을 나타내는 어노테이션이다.
 ![](https://velog.velcdn.com/images/tss9752/post/bb9a4c7b-9b18-42b8-a906-ce3bfc367482/image.png)
 어노테이션을 적으면 자동으로 위에 저렇게 import 문장이 추가될 것이다.

 2. 이제 빈을 설정 클래스에 추가해줄 것이다. 설정 클래스에 빈을 추가하는 방법은, Bean 객체를 생성하는(return 하는) 매소드를 작성하는 것이다. (실제로 빈 이름은 매소드의 이름을 따른다.)   
 그러기 위해서는 먼저 매소드 위에 @Bean 어노테이션을 적어줘야 한다. @Bean 은 이 매소드가 스프링 빈으로서 컨테이너에 추가될 것임을 명시해주는 어노테이션이다.
 ![](https://velog.velcdn.com/images/tss9752/post/cf2d5b6c-be6d-4c08-bc61-55003a8d1937/image.png)

 3. Bean 클래스 타입의 객체를 반환하는 메소드를 생성한다.
![](https://velog.velcdn.com/images/tss9752/post/d650d6ad-9960-456b-9210-1237d0234525/image.png)

---
- test 패키지 내에 테스트 클래스를 생성해, 컨테이너를 만든다.   

 1. test 패키지 내에 테스트 클래스를 생성한다.
 ![](https://velog.velcdn.com/images/tss9752/post/e668cba2-a7b7-44d0-8c35-c7c5706cfb85/image.png) 
 ![](https://velog.velcdn.com/images/tss9752/post/1b532c0a-9fa2-4fc5-96c6-fb6cb3ba6530/image.png)

  2. 다음과 같이 적는다.   
  ![](https://velog.velcdn.com/images/tss9752/post/801b6a45-109f-4c77-b862-8f63c1512c8a/image.png)
 이때 ApplicationContext 와 AnnotationConfigApplicationContext 를 작성할 때마다 엔터나 탭을 눌러 자동 완성 시키면 위에 저렇게 import 문이 자동 생성된다. 뭐가 됐든 저 import 문이 만들어져야 한다.   
 ApplicationContext는 스프링 애플리케이션에서 빈(Bean)을 생성하고 관리하는 컨테이너 역할을 하는 핵심 인터페이스이다. 이 인터페이스의 객체가 컨테이너가 된다. 쉽게 말해서 스프링 컨테이너의 다른 이름이다. 그냥 스프링 컨테이너를 만든다고 보면 된다. 
 AnnotationConfigApplicationContext 은 ApplicationContext의 구현 클래스로, 어노테이션 @Bean 이 달려있는 빈을 찾아 컨테이너 안에 넣는다. 괄호 안에 빈이 담겨 있는 설정 클래스를 넣어준다. 이 메소드는 클래스를 매개변수로 받기 때문에 뒤에 .class 첨자도 넣어줘야 한다.
  
> ApplicationContext \<컨테이너명> = new AnnotationConfigApplicationContext(\<설정 클래스명>.class);

이러면 수동 설정이 끝났다. context 라는 컨테이너 안에 내가 만들었던 myBean 빈이 들어갔을 것이다. 이를 한번 확인해보겠다.   

우리는 테스트용 매소드를 만들어 컨테이너 안을 확인해볼 것이다. 테스트 매소드를 만들기 위해서는 관련 어노테이션인 @Test를 매소드 위에 적어야 한다.  
![](https://velog.velcdn.com/images/tss9752/post/5f94f808-357e-4f8e-a224-9f09c4c29a50/image.png)
 
매소드를 작성해보자.
![](https://velog.velcdn.com/images/tss9752/post/7fd58007-dbf6-4540-82d6-2e3cfdbe8400/image.png)
![](https://velog.velcdn.com/images/tss9752/post/58ffc279-cfe8-452a-97eb-5fb4a6250bb2/image.png)   
for문을 이용하여 컨테이너 안에 있는 모든 빈의 이름을 가져와 이를 출력할 것이다. 여기서 쓰이는 context.getBeanDefinitionNames() 은 컨테이너(context) 안에 있는 모든 빈의 이름을 가져와 배열로 반환하는 매소드다.   

이제 이 메소드를 실행시켜보자.
![](https://velog.velcdn.com/images/tss9752/post/3ba8ed61-f1e6-4194-a3ba-6c73792b278d/image.png)  
![](https://velog.velcdn.com/images/tss9752/post/b33ac0d0-3d70-4745-993e-0e20a702ae43/image.png)
실행시켜보니 이상한 쏼라쏼라 문장이 나오고 맨 마지막 두 줄에 우리가 만들었던 설정 클래스명이랑 빈 클래스 객체 생성 메소드명이 출력되었다. 아까 설정 클래스에서 @Bean 어노테이션을 빈 클래스 객체를 반환하는 메소드 앞에 적어줌으로써 우리가 이 빈을 사용할 것임을 수동으로 등록해주었다. 그리고 빈의 이름은 메소드의 이름을 따르기 때문에, 클래스명인 MyBean이 아닌 매소드명 myBean이 나오는 것이다.   
반면, 설정 클래스명도 출력된 것을 볼 수 있는데, 그 이유는 스프링 컨테이너가 빈을 수동 등록시키는 설정 클래스를 빈으로 생성시켜야만 @Bean 메소드들을 내부적으로 호출할 수 있기 때문이다. 그래서 설정 클래스도 컨테이너 안에 빈으로 생성되어 그 이름이 출력된 것을 확인할 수 있다.

---
- 여기서 주목할 점은, 스프링 프레임워크는 둘 이상의 빈이 똑같은 빈을 요청할 때, 서로 다른 빈을 가져다주는 것이 아니라 동일한 빈을 가져다준다는 것이다. 가령 myBean을 둘 이상의 빈이 요구하면, 그 빈들에게 전달해주는 myBean은 완전히 일치한다.   

이것도 한번 확인해보자. 역시나 테스트 클래스 안에 관련 메소드를 만들어 확인해보겠다.
![](https://velog.velcdn.com/images/tss9752/post/4956de52-733c-4c45-ab8c-e5dbd1894084/image.png)
getOneBeanTest() 라는 메소드를 정의했고, 이 메소드 안에 
```
MyBean myBean1 = context.getBean(MyBean.class);
MyBean myBean2 = context.getBean(MyBean.class);
```
이 있는 것을 확인할 수 있다. 여기서 context.getBean은 컨테이너 안에 있는 빈을 가져와 반환시키겠다는 의미다. 소괄호 안에는 빈의 타입(클래스)를 적어주고 뒤에 .class를 적어준다.   
이러면 myBean1과 myBean2에는 각각 MyBean 클래스 타입을 가지는 빈인 myBean이 대입된다.   

그리고 myBean1, myBean2를 한번 출력해보자.
![](https://velog.velcdn.com/images/tss9752/post/e89006ac-7807-4649-8f5f-a3c7497fe497/image.png)
그랬더니 출력된 내용이 완전히 일치하는 것을 볼 수 있다. 이는 앞서 말했다시피 둘 이상의 빈이 동일한 빈을 요구하면 스프링은 똑같은 빈을 모두에게 반환시켜주기 때문이다.   

추가적으로 Assertion 클래스를 통한 예외 처리에 대해서도 잠깐 알아보겠다.
![](https://velog.velcdn.com/images/tss9752/post/0d9acdde-94a7-4821-ab2f-6a2c5aa46638/image.png)
아까 만든 메소드 맨 아래에 Assertions.assertThat(myBean1).isSameAs(myBean2);를 추가했다. 이 문장은 다음과 같이 이해하면 된다.
> Assertions.assertThat(판정할 대상).\<판정할 대상의 판정 내용>;

 Assertions 클래스 내에 있는 메소드인 assertThat을 통해, 괄호 안에 있는 myBean1을 판정한다. 여기서는 myBean1이 myBean2와 같은지를 판정한다. (isSameAs()는 메소드의 대상과 안의 매개변수가 서로 같은지를 확인하는 메소드다.) 근데 myBean1과 myBean2는 서로 같으므로 assert(예외)가 발생하지 않고 넘어가게 된다.   

---
### 2. 컴포넌트 스캔 (자동등록) 
앞선 수동등록 방식과 달리, 이번에 알아볼 자동등록 방식은 Bean 클래스가 생성하는 객체(빈)를 자동으로 스프링 빈으로 설정시키도록 하는 방식이다. 자동등록 방식은 나중에 애플리케이션이 실행될 때 특정 표식이 있는 객체만 자동으로 빈으로 등록되도록 한다.   

자동등록 방법은 다음과 같다.
1. 빈 클래스 위에 @Component 어노테이션을 쓴다. 이는 자동으로 등록시킬 스프링 빈의 클래스임을 명시해주는 것이다.
2. 설정 클래스 위에 @ComponentScan 어노테이션을 쓴다. 이는 @Component로 등록해놨던 Bean 클래스를 진짜 스프링 빈으로 등록시키겠다는 의미다.

---
- 빈 클래스 위에 @Component 어노테이션을 쓴다.   

 1. 아까 만들어 놓았던 MyBean 클래스 위에 어노테이션을 쓴다.
 ![](https://velog.velcdn.com/images/tss9752/post/5ade0491-97c8-4349-96b1-a95319dbc22b/image.png)

---
- 설정 클래스 위에 @ComponentScan 어노테이션을 쓴다.   

 1. TestConfig 클래스로 돌아가, 클래스명 위에 @ComponentScan 어노테이션을 쓴다.
 ![](https://velog.velcdn.com/images/tss9752/post/e0740b46-f082-4796-85be-bb07b9cfd7ee/image.png)
 자동등록 때 썼던 코드는 모두 주석처리 해준다.
---
BeanTest에서 테스트를 해보자.   

 ![](https://velog.velcdn.com/images/tss9752/post/03d52b74-fcf3-4b67-a018-16918f4930ff/image.png)

자동 등록 방법 때처럼 스프링 빈이 컨테이너에 잘 들어간 것을 확인할 수 있다.   

여기서 궁금증이 들 수 있다.
1. AnnotationConfigApplicationContext 클래스는 수동 방식 때 @Bean이 달린 Bean 클래스를 등록해준다고 했는데, 왜 이 클래스를 자동 방식에도 쓸까?   

2. TestConfig(설정 클래스)에 저렇게 아무 것도 쓰지 않을 거면 굳이 설정 클래스를 쓸 이유가 있을까? 그냥 테스트 클래스에 @ComponenetScan을 달아도 되지 않을까?   

3. 수동등록 방식에서는 @Bean으로 등록한 메소드의 이름이 빈의 이름이 됐다. 근데 자동등록 방식에서 @Bean으로 등록한 메소드를 모두 주석처리 했는데, 보니까 빈의 이름이 ```myBean```으로 잘 출력됐다. 어떻게 된 일일까?

이걸 하나씩 풀어보겠다.

---
1. **AnnotationConfigApplicationContext 클래스는 수동 방식 때 @Bean이 달린 Bean 클래스를 등록해준다고 했는데, 왜 이 클래스를 자동 방식에도 쓸까?**   

   사실, AnnotationConfigApplicationContext는 수동등록과 자동등록 모두에 사용될 수 있는 범용 컨테이너 클래스다. 이 클래스가 자동등록에 쓰일 시, @Component와 @ComponentScan으로 등록된 스프링 빈을 컨테이너에 등록해준다.

2. **TestConfig(설정 클래스)에 저렇게 아무 것도 쓰지 않을 거면 굳이 설정 클래스를 쓸 이유가 있을까? 그냥 테스트 클래스에 @ComponenetScan을 달아도 되지 않을까?**   

   결론부터 말하자면 설정 클래스를 쓰지 않고 바로 테스트 클래스에 @ComponentScan을 써도 스프링 빈 등록이 가능하다.
   ![](https://velog.velcdn.com/images/tss9752/post/05c50d18-0b80-4c41-8122-99da3d2e9ba2/image.png)
   하지만, 이렇게 하지 않는 이유는 테스트 클래스 파일과 설정 클래스 파일을 구분짓기 위해서다. 테스트 클래스는 프레임워크를 테스트하기 위한 파일이지, 스프링 빈을 등록하는 파일이 아니다. 스프링 빈을 등록하는 클래스 파일 따로, 테스트하는 클래스 따로 분리시켜서 작성하는 것이 프레임워크 구조의 가독성과 직관성을 높여준다.   

3. **수동등록 방식에서는 @Bean으로 등록한 메소드의 이름이 빈의 이름이 됐다. 근데 자동등록 방식에서 @Bean으로 등록한 메소드를 모두 주석처리 했는데, 보니까 빈의 이름이 ```myBean```으로 잘 출력됐다. 어떻게 된 일일까?**
   
   수동등록 방식에서는 @Bean으로 등록한 메소드명이 빈의 이름이 된다. 하지만 자동등록 방식에서는 빈의 이름이 클래스명을 따라간다. 아까 우리가 만든 시험용 Bean 클래스명이 MyBean이었는데, 자동등록 방식에서는 이를 camal case로 바꿔 빈 이름으로 등록시킨다. (camel case란, 모든 단어를 소문자로 쓰되 단어의 첫 글자를 대문자로 구분하는 방식이다. 예를 들어 mybean은 myBean으로 작성한다.)   

   (앞으로 빈은 모두 자동등록한다고 가정한다. 그래서 빈의 이름이 모두 Bean 클래스명의 캐멀스타일 버전이라고 하겠다.)
---
### 스프링 빈을 가져오는 방법
앞에서 본 사진을 다시 가져와보겠다.
![](https://velog.velcdn.com/images/tss9752/post/e8515fd4-c221-4b36-8af4-8248750a4fe6/image.png)
스프링 빈이 프레임워크에게 다른 빈을 달라고 요청하면, 컨테이너 내에 있는 빈을 가져다준다고 했다. 그리고 우리는 다음 2가지도 추가로 배웠다:   
>- 스프링 빈을 요구하는 주체도 스프링 빈이다.
>- 둘 이상의 빈이 동일한 빈을 요구하면, 각각에게 완전히 동일한 빈이 제공된다.

여기서 **"스프링 빈을 요구하는 주체도 스프링 빈이다."** 를 좀 더 깊게 파고들어 의존성 개념에 대해 알아보겠다.

---
### 의존성과 의존성 주입(dependency injection)
자동차는 타이어가 없으면 달리지 못한다. 엔진이 없어도 달리지 못하고, 브레이크가 없으면 매우 위험한 병기가 될 것이다. 다시 말해서, 완성품 자동차는 타이어, 엔진, 브레이크 등에 **의존**하고 있다.   

![](https://velog.velcdn.com/images/tss9752/post/c2c00415-b0af-4c29-bf1f-a90719bfdf2e/image.png)
위 사진에서도 스프링 빈이 다른 스프링 빈을 요청하고 있다. 마치 자동차가 타이어와 엔진과 브레이크를 요청하는 것처럼. 그렇다면 스프링 빈도 다른 스프링 빈에게 의존하는 것이 아닐까?

의존성이란 이런 개념이다. 스프링(스프링부트) 프레임워크에서의 의존성이란, 스프링 빈이 다른 빈을 필요로 하는 성질을 의미한다.   
가령, 웹 페이지에서 로그인을 할 때 뿐만 아니라 비밀번호 찾기, 기타 개인정보 변경 시에도 로그인을 해야한다고 하자. 그러면 비밀번호를 찾는 클래스(빈)과 개인정보를 변경하는 클래스(빈)이 로그인 기능을 담당하는 클래스(빈)에게 의존하고 있다. 이것이 의존성이다.  

그렇다면 빈이 지금 필요한 다른 빈을 어떻게 얻을까? 

가령 자동차가 타이어, 엔진, 브레이크가 필요하면, 타이어와 엔진과 브레이크 등등 모든 부품을 처음부터 끝까지 모두 만들어 사용할까? 당연히 아닐 것이다. 이미 만들어진 부품을 사용할 것이다. 스프링에서도 동일하다.   

> ![](https://velog.velcdn.com/images/tss9752/post/a3b9270a-106a-43c0-9231-2f192a6e21d4/image.png)

아까 위에서 설명했던 내용이다. 빈을 사용할 때는 컨테이너에 직접 접근해서 빈을 꺼내지 않고, 프레임워크에게 필요한 빈을 가져와달라고 요청한다. 가령 스프링 빈1이 스프링 빈5를 필요로 하면, 빈1 클래스 내부에서 빈5 클래스를 처음부터 끝까지 전부 구현하지 않는다. 컨테이너에 등록되어 있는 빈을 가져다 사용한다.    
다시 말해서, 컨테이너가 빈 간의 의존성을 관리해준다. 이것을 정식 용어로는 컨테이너가 스프링 빈에게 의존성을 주입(dependency injection)한다고 한다. 컨테이너가 빈 간의 의존성을 주입해줌으로써 필요한 객체를 전달해준다고 생각하면 편하다.

당연하겠지만 컨테이너 내에서 이미 만들어진 객체를 전달받기만 하면 매우 편리할 것이다. 빈이 직접 필요한 빈을 처음부터 일일이 만들 필요가 없기 때문이다. 이 덕분에 코드 유지보수가 편해진다.   

---
### 의존성 주입 방법
이제 빈 간의 의존성을 주입하는 방법에 대해 알아보겠다. 의존성을 주입하는 방법은 총 3가지가 있다.
1. 생성자를 이용하는 방법
2. 필드를 이용하는 방법
3. ~~메소드를 이용하는 방법~~ (잘 안 쓰임)  

위 모든 방법이 필수로 가져야 하는 요소가 있다.   
프레임워크가 빈에게 다른 빈을 주입하려면(제공하려면), 그 빈을 주입하기 위한 통로가 필요하다. 그래서 우리는 그 통로를 만들어주고, 통로를 통해 주입해달라고 표시해야 한다. 그러면 프레임워크가 알아서 객체를 주입해줄 것이다.

먼저 의존할 빈을 만들어보자.   

MyBean 클래스 바로 밑에 MySubBean 이라는 클래스를 생성한다.
![](https://velog.velcdn.com/images/tss9752/post/bff54576-9eb8-40ef-8c62-999a191b1d2f/image.png)   

해당 클래스를 @Componenet 로 자동 등록한다.
![](https://velog.velcdn.com/images/tss9752/post/db0d5efa-7a6b-447c-9b35-6bc098cc2c3e/image.png)

이제 MyBean이 의존할 빈인 MySubBean을 만들었다. 이제 이 빈을 주입해줄 통로를 만들자.   

- 통로는 아까 위에서 보았던 생성자, 필드, 메소드를 이용하는 방식을 통해 만든다.    
- @Autowired 어노테이션을 의존할 빈 위에 적어주면 통로 표시도 할 수 있다.   

---
### 생성자를 이용한 통로 만들기

순서는 다음과 같다.

1. 의존하는 클래스(MyBean)에 의존할 빈(MySubBean)의 필드를 생성한다.
2. 의존할 빈(MySubBean)의 생성자를 적어준다.    
3. @Autowired로 통로를 등록한다.
4. @Getter로 getter를 추가해준다.

---
- 의존하는 클래스(MyBean)에 의존할 빈(MySubBean)의 필드를 생성한다.
![](https://velog.velcdn.com/images/tss9752/post/0a9ab541-8d48-4341-9b0a-36cb1db01b74/image.png)
(빨간줄은 무시해도 된다.)   

   MySubBean 타입을 가지는 mySubBean은 변경되면 안되고, 외부에서의 접근을 제한하고 싶으니 private final 키워드를 사용한다.

 - 의존할 빈(MySubBean)의 생성자를 적어준다. 
 ![](https://velog.velcdn.com/images/tss9752/post/410d3233-e75c-4ad2-8022-a6e0b5784ded/image.png)
 역시나 생성자를 함부로 사용하지 못하게 해야 하니 private로 보호한다.

 - @Autowired로 통로를 등록한다.
![](https://velog.velcdn.com/images/tss9752/post/f0a43747-2d1e-48fe-9deb-7cf7b98d5d57/image.png)

 - @Getter로 getter를 추가해준다.
![](https://velog.velcdn.com/images/tss9752/post/e5a19d41-3f19-4e23-9c99-e0d01dd3ab2e/image.png)

@Getter 어노테이션은 롬북(lombok)에서 제공하는 것으로, 적으면 클래스 내에 있는 필드의 getter를 추가해준다. 현재 필드를 private로 막아놨기 때문에, 필드의 값을 가져오려면 getter를 추가해줘야 하는 상황이다. 그것을 @Getter 어노테이션으로 추가해준다. 이러면 별도로 개발자가 getter 메소드를 작성하지 않아도 자동으로 추가된다.    

여기서 롬북에서 제공하는 또 하나의 강력한 어노테이션인 @RequiredArgsConstructor가 있다.   
이 어노테이션을 사용하면, final 필드에 대한 생성자도 자동으로 추가해준다. 그래서 별도로 생성자를 만들지 않아도 된다.
![](https://velog.velcdn.com/images/tss9752/post/fe305188-d9c0-4a86-8ede-ee12c6cc24c4/image.png)

\+ 추가로, 만약 클래스 내에서 통로가 하나만 존재할 경우, @Autowired 어노테이션을 생략해도 통로로 등록된다.
![](https://velog.velcdn.com/images/tss9752/post/49599a6b-7db6-4812-9585-01b99dc6bfc0/image.png)   

---
> 여기부터는 아직 작성이 완료되지 않은 부분입니다. 미작성된 내용은 다음과 같습니다.   
> - 필드 주입방식
> - spring layered architecture
>
> 시험기간임에도 매일 3~4시간씩 글 작성에 여념하다 결국 과제 기한을 지키지 못해 미완성된 채임을 부디 이해해주시길 바랍니다.....ㅠㅠ 곧 돌아와 완성시킬게요


### 필드를 이용한 통로 만들기   
필드 방식을 알아보기 전, 스프링에서 쓰이는 리플렉션을 이해해야 한다.
리플렉션이란 자바가 클래스를 조작하고 관리하는 기능이다. 
1. 컨테이너가 있음
2. 스프링 컨테이너에는 이미 자신이 의존하는 빈이 등록된 상태
3. 자신의 필드에 컨테이너에 있는 빈값을 강제로 쑤셔넣음
4. 3번 빈을 컨테이너에 넣음
이 과정에서 클래스 내에 있는 필드는 제한자 상관 없이 접근되어 특정 값을 대입받는다. (필드를 초기화하는 과정이라고 생각하면 된다.)   

필드 통로를 이용하여 빈의 의존성이 주입되는 과정은 다음과 같다.

1. 필드에 바로 @Autowired 사용 (final 사용 불가)
2. 주로 테스트코드에서 사용함 (main에서 쓰면 경고 발생)

---
### 스프링 layered Architecture (애플리케이션을 개발할 때 어떻게 개발할 것인지에 대한 구조)
컨트롤러 -dto-> 서비스 -dto,엔티티-> 레포지토리 -엔티티-> db (db빼면 다 스프링임)
컨트롤러가 요청을 받아들이고, 서비스는 그 요청을 관리하고, 서비스의 요청을 레포지토리가 받아들임(분담)
-컨트롤러: 클라이언트의 요청을 받아 응답을 보내는 계층
dto를 사용하여 서비스 계층과 데이터를 주고받는다
-서비스: 애플리케이션의 비즈니스 로직이 담기는 계층(실질적인 애플리케이션이 해야할 일을 비즈니스 로직이라고 함)
레포지토리와 소통하며 엔티티 또는 dto로 소통한다.
-레포지토리 : db와 소통하면 데이터를 조작하는 계층. 실제 비즈니스 로직을 db에 적용한다.

이 모든건 다 스프링빈으로 등록한다.

---
(GDGoC 백엔드 스터디 과제 제출용)

![](https://velog.velcdn.com/images/tss9752/post/4f266caf-c311-47fe-91e1-eccbdd226997/image.png)
